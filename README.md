# APE - Abstract Processor Emolator
## Введение
Реализация эмулятора простого процессора (и некоторой переферии).

Этот проект я начал делать просто что бы занять пару-тройку вечеров.
Основные цели проекта:
- Улучшить понимание устройства процессора
- Поиграться с ассемблером

С первым я определённо справился.
Но это не отражено в коде.
Реализовал я именно эмулятор, без прямой реализации принципиальных схем.
Но опишу тут своё понимание и того и другого.

Зачем я это всё пишу?
В первую очередь для себя.
Пригодится.

## Система
Всё что должен делать процессор - это просто выполнять последовательно команды. А команды хранятся в памяти.
Почитав различные материалы на темы строения процессора и материнской платы я составил такую обобщённую систему:

- Есть собственно процессор. В нём есть регистры и логика работы.
- И есть внешние устройства.

Более ничего.

Процессор содержит следующие регистры:
Регистры общего назначения: **RM0**, **RM1**, **RM2**, **RM3**
Они предназначены для любых операций.

Регистры стеков: **RS0**, **RS1**, **RS2**, **RS3**
Указывают на вершины стеков, ага.

Рабочие регистры:
    **RIP** - адрес команды
    **RDC** - адрес устройства исполнения - с какого устройства будет читаться следующая команда
	**RDR** - адрес устройства чтения/записи - с каким устройством будут работать команды чтения/записи
    **RPF** - регистр флагов
    **RTX** - таймер
Регистр ограничения доступа к памяти:
    **RLM** - нижняя граница
    **RHM** - верхняя граница

Устройства представляют собой очень простой интерфейс реализующий чтение и запись по указанному адресу.

В текущей реализации я создал два устойства:
- Оперативную память по адресу 0
- Загрузочную неизменяемую память по адресу 4096
При запуске исполнение начинается именно со второго.



## Ассемблер

Набор команд я накидал очень минимальный исходя из своих скудных представлений о ассемблере:
- Пустая операция: **NOP**
- Остановка эмуляции: **INT**
- Перемещение значений: **MOV**, **PUSH**, **POP**
- Перемещения исполнения: **JMP**, **JZ**, **JNZ**
- Битовые операции: **NOT**, **AND**, **OR**, **XOR**
- Математические (целочисленные): **ADD**, **SUB**, **MUL**, **DIV**, **MOD**, **INC**, **DEC**

У операций может быть указан размер данных с которыми они работают.
- BYTE = 1 байт
- WORD = 2
- DWORD = 4
- QWORD = 8
Я планирую в компиляторе языка определять это окончанием команды: **MOVB**, **MOVW**, **MOVD**, **MOVQ**
На данный момент нет полноценного компилятора (я хотел бы написать его уже на самом ассемблере)
Но есть специальный класс Assembler, который позволяет сгенерировать программу прямо в коде C#
Для написания полноценного компилятора нужен только парсер.

Этих команд вполне хватило для написания простенькой программы, которая должна переносить фразу *Hello, World!* с загрузочного диска в оперативную память.

Программа уже работает, но требует отладки - пока копируется какой-то один символ %)



## Понимание архитектуры и микрокоды

Отдельно скажу про понимание устройства процессора.
Если раньше (ещё со времён майнкрафта) восприятие было не полным и казалось что процессор состоит из кучи хитро связанных устройств, то сейчас пришло некоторое понимание.
Особенно после того как я наткнулся на такую тему как микрокоды.
Идея микрокодов: инструкции ассемблема сами тоже не атомарные - внутри процессора каждая из них описывается набором ещё более базовых инструкций.

И из этой простой идеи родилось такое понимание:
- Есть набор блоков - Регистры, Эн/Де-кодеры, Сумматора, и прочая и прочая.
  Всё это - логические устройства в кристалле процессора, имеющие входы и выходы
- И есть шины - по сути наборы проводов, соединяющие эти устройства.

Так вот микрокоманды - это простейшие указания, какое устройство к какой шине и каким концом подсоединять.
И реально вся логика работы каждой команды может быть описана таким простым способом.

То есть например команда:
JMP relative

И её можно разбить на операции устройств процессора:
Получение relative
- инкремент регистра адреса команды
- подсоединить временный регистр к шине входных данных

Вычисление адреса
- подсоединить временный регистр к шине 1
- подсоединить регистр адреса команд к шине 2
- подсоединить сумматор к шинам 1 и 2
- подсоединить вывод сумматора к шине 3
- подсоединить второй временный регистр к шине 3
- отсоединить всё - сумма во временном регистре
- подсоединить временный регистр к шине 1
- подсоединить регистр адреса к шине 1
- отсоединить всё - регистр адреса указывает в новое место

Это конечно очень условный псевдокод, но я лично вижу за ним цельную архитектуру кристалла, который может в итоге иметь чертовски комплексную логику за счёт вот таких микропрограмм. И что самое главное - такой кристалл получается довольно универсальным!

M устройств (у каждого вход и выход)
N шин данных

Конечно в коде я сейчас такого не сделал - код я сел писать что бы с ассемьлером поиграться, но всё же!







