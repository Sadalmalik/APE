Итак.
Я решил замутить виртуальный процессор что бы поиграться.
Сначала была мысль собрать полноценную логическую схему...
Я это могу, но: наифга? Это займёт прорву времени и не будет так интересно.

Так что я решил смастерить его на уровне компонентов самого процессора - регистров, шин и прочего.

Схема такая:
 - Есть регистры - специальные переменные, куда всё сваливается.
   Я наделал их по аналогии с x86-64
 - Есть ядро - это условно процессор и материнская плата.
   Почему условно? Потому что ядро будет на прямую взаимодействовать с устройствами: оперативной памятью, вводом-выводом и прочими.
   Все устройства работают через стандартный интерфейс - таким образом я эмулирую шину на материнской плате.

Вот примерно как-то так.
При этом я естесственно опущу многие тонкости.
Например чтение и анализ команд будет происходить за один тик, хотя в реальном процессоре это может занимать гораздо больше.
В то же время я хочу попробовать сделать задржки устройств.
Например "жёсткий диск" будет отдавать данные по запросу по прошествии некоторого времени.

Посмотрим что получится.





Система Инструкций.
Прежде всего команда бездействия.
Не знаю, почему в x86 эта команда имеет номер 0x90...


У нас имеются следующие регистры:
Регистры общего назначения
    RG0, RG1, RG2, RG3
Регистры стеков
    RS0, RS1, RS2, RS3
Рабочие регистры:
    RIP - адрес команды
    RDI - адрес устройства
    RPF - регистр флагов
    RTX - таймер
Регистр ограничения доступа к памяти:
    RLM - нижняя граница
    RHM - верхняя граница


Вообще какие у нас есть инструкции?

Инструкции могут работать:
- с регистрами
- с устройством (шиной),
- с регистром и устройством одновременно (чтение из памяти в регистр)

Попробуем описать все основные инструкции.

Во первых размеры данных:
- 1 байт
- 2 байта
- 4 байта
- 8 байт
4 варианта - хватит 2-х бит в команде.

Перемещение значения:
- Из регистра в регистр
- Из регистра в девайс
- Из девайса в регистр
- Из константы в регистр (прямая запись значения, указанного в инструкции)
- Из константы в память

Стековые операции:
- Из регистра в стек
- Из стека в регистор
- Из памяти в стек
- Из стека в память
- Из константы в стек
По умолчанию используется адрес стека из регистра RS0

Битовые операции:
- Сдвиг влево
- Сдвиг вправо
- Побитовое И
- Побитовое ИЛИ
- Побитовое НЕ
- Побитовое исключающее НЕ

Математические операции:
- Инкремент
- Декремент
- Сложение
- Вычитание
- Умножение
- Деление
- Остаток

Прыжок:
- Простой прыжок
  Выполняется относительно собственного адреса
- Условный прыжок
  Проверяет что в заданном регистре ноль или не ноль и прыгает если проверка выполнилась/не выполнилась.

Итого:
Хочется умещать команды в 1-2 байта.
Но с имеющимся колличеством регистров не очень получится.
Причина проста:
длинна идентификатора регистра.
Если регистров 16, как у меня, то это 4 бита.
Самая простые команды:
- Инкремент/декремент
- Присвоить в регистр константу

Первую ещё можно было бы уместить в 1 байт...
то со значением получается такая шняга:
нужно 4 бита на номер регистра
плюс нужно 2 бита на размер данных.
8 - 2 - 4 = 2 бита на идентификатор команды.
Все команды должны быть отличимы друг от друга.

По ощущениям для эффективной организации системы команд можно построить бинарное дерево.
Ноо. Для домашнего проектика - сложновато. Мне лень.

Так что экономить не будем.
Первая половина байта - группа команд (перемещения, стек, адресация, битовые, математика)
Вторая половина - уточнения, размеры и прочее.
Адреса регистров во втором байте.
Если регистр один - то только последние 4 бита.

Минус эффективность.
Плюс простота.

0000 0000 NOP
1000 0000 MOV
0100 0000 PUSH/POP
1100 0000 AND/OR/NOT/XOR
0010 0000 INC/DEC/ADD/SUB/MOL/DIV/MOD/DMOD
1010 0000 JMP/JZ/JNZ
0110 0000
1110 0000

...

А вот хрен там плавал)
INC/DEC/ADD/SUB/MOL/DIV/MOD/DMOD
не уместить в пару бит между номером команды и размером.
8 команд - 3 бита

сделаем так:
3 бита - категория
3 бита - команда
2 бита - размер
Алсо, добавлять биты слева я начал что бы команды сразу заметно отличались от данных.
У данных старшие биты с большей вероятностью могут быть нулевыми.

Пробую снова

000 - Нет категории
000 000 00  NOP

100 - Базовые команды
100 000 00  MOV reg, reg
100 001 00  MOV reg, [reg]
100 010 00  MOV [reg], reg
100 011 00  MOV [reg], [reg]
100 100 00  MOV const, reg
100 101 00  MOV const, [reg]
100 110 00  MOV reg, [const] // Как иначе писать в предзаданные переменные?
100 111 00  MOV [const], reg

010 - Операции со стеком
010 000 00  PUSH reg
010 001 00  POP reg
010 010 00  PUSH reg, <reg>
010 011 00  POP reg, <reg>
010 100 00  -undefined-
010 101 00  -undefined-
010 110 00  -undefined-
010 111 00  -undefined-
Тут первые две операции эквивалентны таким
PUSH reg, RS0
POP reg, RS0

110 - адресные операции
110 000 00  JMP const
110 001 00  JMP reg
110 010 00  -undefined-
110 011 00  -undefined-
110 100 00  JPZ reg, const
110 101 00  JPZ reg, reg
110 110 00  JNZ reg, const
110 111 00  JNZ reg, reg
UPD: произвёл реордер команд для удобства построения компиляции
Теперь
 - Четвёртый бит - флаг условности
 - Пятый - инверсии условности.
Главное нигде не проебвть этот момент!

001 - Битовые операции
001 000 00  NOT reg
001 001 00  AND reg, reg
001 010 00  OR reg, reg
001 011 00  XOR reg, reg
001 100 00  -undefined-
001 101 00  -undefined-
001 110 00  -undefined-
001 111 00  -undefined-

101 - Математика
101 000 00  ADD reg, reg
101 001 00  SUB reg, reg
101 010 00  MUL reg, reg
101 011 00  DIV reg, reg
101 100 00  MOD reg, reg
101 101 00  -undefined-
101 110 00  -undefined-
101 111 00  -undefined-

Вроде всё.

Ещё посидел, понял что можно добавить 4 однобайтовые команды

011 - Однобайтовые
011 0 0000  INC reg
011 1 0000  DEC reg

111 0 0000  -undefined-

Прерывание исполнения
11111111 INT





---

В классической архитектуре 86 размер аргумента определялся разными способами через определения регистров.
При этом там много легаси команд и тотальная обратная совместимость.

Я размер данных буду определять через окончание команды b, w, d, q
    MOVB reg, reg ; 1 байт
    MOVW reg, reg ; 2 байта
    MOVD reg, reg ; 4 байта
    MOVQ reg, reg ; 8 байт
То же самое для всех остальных команд
Считаю так будет проще как для понимания так и для написания компилятора.





























